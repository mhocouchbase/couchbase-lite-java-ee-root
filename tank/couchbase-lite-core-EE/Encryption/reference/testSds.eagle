###############################################################################
#
# testSds.eagle --
#
# Test script for System.Data.SQLite with the SQLite Encryption
# Extension (SEE)
#
# Copyright (c) 2004-2008 Hipp, Wyrick & Company, Inc.
# 6200 Maple Cove Lane, Charlotte, NC 28269 USA
# +1.704.948.4565
#
# All rights reserved.
#
###############################################################################
#
# ----------------------
# HOW TO USE THIS SCRIPT
# ----------------------
#
#    1. First, execute one of the "buildSds*.bat" batch tools in order to build
#       the System.Data.SQLite binaries with SEE enabled.  This should also end
#       up copying the necessary managed / native binaries to directories where
#       Eagle and the CLR can easily find them.
#
#    2. Execute this tool using a command similar to the following:
#
#           EagleShell.exe -file testSds.eagle
#
#    This script makes certain assumptions about how the System.Data.SQLite
#    and SEE source trees are laid out.  If those layouts change, this script
#    will need to be updated as well.
#
###############################################################################

set script [info script]
set path [file dirname $script]
set dbFileName(1) [file join $path test1.db]
set dbFileName(2) [file join $path test2.db]
set dbFileName(3) [file join $path test2.db]; # not a typo
set dbFileName(4) [file join $path test4.db]
set password(1) aes256:1234
set password(2,sds) aes256:\x7E\\\x3B\\\x22\x01\x63\x74\x0A\x1D
set password(2,shell) aes256:\x7E\x3B\\\x22\x01\x63\x74\x0A\x1D
set password(3) [appendArgs 6165733235363A 7E3B220163740A1D]
set password(4) [appendArgs 6165733235363A F13B2201E374ACD1]

###############################################################################

if {[isWindows]} then {
  set seeExeFileName [file join $path bld see.exe]
} else {
  set seeExeFileName [file join $path see]
}

###############################################################################

if {![info exists no(copySdsFiles)]} then {
  #
  # NOTE: Procedure copied from "lib/System.Data.SQLite/common.eagle" in
  #       the System.Data.SQLite source tree.  It is designed to return
  #       non-zero when running on the Mac OS or iOS operating systems.
  #
  proc isDarwin {} {
    return [expr {
      [info exists ::tcl_platform(os)] && $::tcl_platform(os) eq "Darwin"
    }]
  }

  set done(managed) false; set done(native) false
  set copied(managed) false; set copied(native) false
  set message(managed) false; set message(native) false

  if {![info exists root_path]} then {
    set root_path [file join [file dirname $path] dotnet]
  }

  if {[isDotNetCore]} then {
    set managedYears [list \
        NetStandard20 NetStandard20 NetStandard20 NetStandard20 \
        NetStandard20 NetStandard20 NetStandard20]

    set nativeYears [list 2017 2015 2013 2012 2010 2008 2005]
    set extraSourceDirectory netstandard2.0
    set extraTargetDirectory netStandard20
  } else {
    set managedYears [list 2017 2015 2013 2012 2010 2008 2005]
    set nativeYears $managedYears
    set extraSourceDirectory ""
    set extraTargetDirectory netFramework40
  }

  if {![info exists configuration]} then {
    set configuration Release
  }

  if {![info exists suffix]} then {
    if {[isDotNetCore]} then {
      set suffix NetStandard20
    } elseif {[isMono]} then {
      set suffix MonoOnPosix
    } else {
      set suffix ""
    }
  }

  if {[isWindows]} then {
    set nativeFileNameOnly SQLite.Interop.dll
  } elseif {[isDotNetCore]} then {
    set nativeFileNameOnly SQLite.Interop.dll
  } elseif {[isDarwin]} then {
    set nativeFileNameOnly libSQLite.Interop.dylib
  } else {
    set nativeFileNameOnly libSQLite.Interop.so
  }

  foreach managedYear $managedYears nativeYear $nativeYears {
    set sourceFileName [file join \
        $root_path bin $managedYear [appendArgs $configuration \
        $suffix] bin $extraSourceDirectory System.Data.SQLite.dll]

    set targetFileName [file join \
        $root_path Externals Eagle bin $extraTargetDirectory \
        System.Data.SQLite.dll]

    if {[file exists $targetFileName]} then {
      set done(managed) true
    } elseif {[file exists $sourceFileName]} then {
      file copy $sourceFileName $targetFileName
      set done(managed) true; set copied(managed) true
    }

    if {$copied(managed) && !$message(managed)} then {
      host result Ok [appendArgs \
          "Managed binary copied from \"" $sourceFileName \
          "\" to \"" $targetFileName "\".\n"]

      set message(managed) true
    }

    set sourceFileName [file join \
        $root_path bin $nativeYear [appendArgs $configuration \
        $suffix] bin $nativeFileNameOnly]

    set targetFileName [file join \
        $root_path Externals Eagle bin $extraTargetDirectory \
        $nativeFileNameOnly]

    if {[file exists $targetFileName]} then {
      set done(native) true
    } elseif {[file exists $sourceFileName]} then {
      file copy $sourceFileName $targetFileName
      set done(native) true; set copied(native) true
    }

    if {$copied(native) && !$message(native)} then {
      host result Ok [appendArgs \
          "Native binary copied from \"" $sourceFileName \
          "\" to \"" $targetFileName "\".\n"]

      set message(native) true
    }

    if {$done(managed) && $done(native)} then {
      break
    }
  }

  #
  # NOTE: If a file was copied, re-launch this process; otherwise, they
  #       may not be properly detected by the CLR runtime.
  #
  if {$copied(managed) || $copied(native)} then {
    set newArgv [list -file $script]
    if {[llength $argv] > 0} then {eval lappend newArgv $argv}
    eval execShell [list [list -nocapture]] $newArgv; exit 0
  }
}

###############################################################################

if {[catch {object load System.Data.SQLite}] == 0} then {
  set pattern {strcmp\(zPassPhrase, "(.*?)"\)==0;}
  set sourceFileName [file join $path see.c]

  if {![regexp -- $pattern \
      [readFile $sourceFileName] dummy passphrase]} then {
    error "failed to locate the SEE activation passphrase"
  }

  object invoke System.Data.SQLite.SQLiteCommand Execute [subst \
      {PRAGMA activate_extensions='see-${passphrase}';}] NonQuery \
      null

  host result Break "Activation with System.Data.SQLite completed.\n"
} else {
  host result Continue "Cannot load System.Data.SQLite, activation skipped.\n"
}

###############################################################################

if {[catch {object load System.Data.SQLite}] == 0} then {
  set connection [sql open -type SQLite [subst \
      {Data Source=${dbFileName(1)};Password=${password(1)};}]]

  sql execute $connection {
    CREATE TABLE IF NOT EXISTS t1(x);
  }

  sql execute $connection {
    DELETE FROM t1;
    INSERT INTO t1(x) VALUES('This will be encrypted.');
  }

  sql execute $connection {
    VACUUM;
  }

  set expected(1) {{This will be encrypted.}}

  set data(1) [sql execute -execute reader -format list \
      $connection {SELECT * FROM t1;}]

  if {$data(1) eq $expected(1)} then {
    host result Ok [appendArgs "PHASE #1: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #1: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(1) \}\n]
    host result Error [appendArgs "  Got: \{" $data(1) \}\n]
  }

  sql close $connection
} else {
  host result Continue "Cannot load System.Data.SQLite, test #1 skipped.\n"
}

###############################################################################

if {[file exists $seeExeFileName]} then {
  set expected(2) [string trim {
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE t1(x);
INSERT INTO t1 VALUES('This will be encrypted.');
COMMIT;
  }]

  set data(2) [string trim [string map [list \r\n \n] \
      [exec -success Success -- $seeExeFileName -key [appendArgs \
      \" $password(1) \"] $dbFileName(1) .dump]]]

  if {$data(2) eq $expected(2)} then {
    host result Ok [appendArgs "PHASE #2: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #2: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(2) \}\n]
    host result Error [appendArgs "  Got: \{" $data(2) \}\n]
  }
} else {
  host result Continue [appendArgs \
      "SEE shell \"" $seeExeFileName "\" not found, test #2 skipped.\n"]
}

###############################################################################

if {[catch {object load System.Data.SQLite}] == 0} then {
  set connection [sql open -type SQLite [subst \
      {Data Source=${dbFileName(2)};Password=${password(2,sds)};}]]

  sql execute $connection {
    CREATE TABLE IF NOT EXISTS t1(x);
  }

  sql execute $connection {
    DELETE FROM t1;
    INSERT INTO t1(x) VALUES('This will be encrypted.');
  }

  sql execute $connection {
    VACUUM;
  }

  set expected(3) {{This will be encrypted.}}

  set data(3) [sql execute -execute reader -format list \
      $connection {SELECT * FROM t1;}]

  if {$data(3) eq $expected(3)} then {
    host result Ok [appendArgs "PHASE #3: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #3: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(3) \}\n]
    host result Error [appendArgs "  Got: \{" $data(3) \}\n]
  }

  sql close $connection
} else {
  host result Continue "Cannot load System.Data.SQLite, test #3 skipped.\n"
}

###############################################################################

if {[file exists $seeExeFileName]} then {
  set expected(4) [string trim {
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE t1(x);
INSERT INTO t1 VALUES('This will be encrypted.');
COMMIT;
  }]

  set data(4) [string trim [string map [list \r\n \n] \
      [exec -success Success -- $seeExeFileName -key [appendArgs \
      \" $password(2,shell) \"] $dbFileName(2) .dump]]]

  if {$data(4) eq $expected(4)} then {
    host result Ok [appendArgs "PHASE #4: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #4: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(4) \}\n]
    host result Error [appendArgs "  Got: \{" $data(4) \}\n]
  }
} else {
  host result Continue [appendArgs \
      "SEE shell \"" $seeExeFileName "\" not found, test #4 skipped.\n"]
}

###############################################################################

if {[catch {object load System.Data.SQLite}] == 0} then {
  set connection [sql open -type SQLite [subst \
      {Data Source=${dbFileName(3)};HexPassword=${password(3)};}]]

  sql execute $connection {
    CREATE TABLE IF NOT EXISTS t1(x);
  }

  sql execute $connection {
    DELETE FROM t1;
    INSERT INTO t1(x) VALUES('This will be encrypted.');
  }

  sql execute $connection {
    VACUUM;
  }

  set expected(5) {{This will be encrypted.}}

  set data(5) [sql execute -execute reader -format list \
      $connection {SELECT * FROM t1;}]

  if {$data(5) eq $expected(5)} then {
    host result Ok [appendArgs "PHASE #5: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #5: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(5) \}\n]
    host result Error [appendArgs "  Got: \{" $data(5) \}\n]
  }

  sql close $connection
} else {
  host result Continue "Cannot load System.Data.SQLite, test #5 skipped.\n"
}

###############################################################################

if {[file exists $seeExeFileName]} then {
  set expected(6) [string trim {
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE t1(x);
INSERT INTO t1 VALUES('This will be encrypted.');
COMMIT;
  }]

  set data(6) [string trim [string map [list \r\n \n] \
      [exec -success Success -- $seeExeFileName -hexkey [appendArgs \
      \" $password(3) \"] $dbFileName(3) .dump]]]

  if {$data(6) eq $expected(6)} then {
    host result Ok [appendArgs "PHASE #6: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #6: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(6) \}\n]
    host result Error [appendArgs "  Got: \{" $data(6) \}\n]
  }
} else {
  host result Continue [appendArgs \
      "SEE shell \"" $seeExeFileName "\" not found, test #6 skipped.\n"]
}

###############################################################################

if {[catch {object load System.Data.SQLite}] == 0} then {
  set connection [sql open -type SQLite [subst \
      {Data Source=${dbFileName(4)};HexPassword=${password(4)};}]]

  sql execute $connection {
    CREATE TABLE IF NOT EXISTS t1(x);
  }

  sql execute $connection {
    DELETE FROM t1;
    INSERT INTO t1(x) VALUES('This will be encrypted.');
  }

  sql execute $connection {
    VACUUM;
  }

  set expected(7) {{This will be encrypted.}}

  set data(7) [sql execute -execute reader -format list \
      $connection {SELECT * FROM t1;}]

  if {$data(7) eq $expected(7)} then {
    host result Ok [appendArgs "PHASE #7: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #7: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(7) \}\n]
    host result Error [appendArgs "  Got: \{" $data(7) \}\n]
  }

  sql close $connection
} else {
  host result Continue "Cannot load System.Data.SQLite, test #7 skipped.\n"
}

###############################################################################

if {[file exists $seeExeFileName]} then {
  set expected(8) [string trim {
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE t1(x);
INSERT INTO t1 VALUES('This will be encrypted.');
COMMIT;
  }]

  set data(8) [string trim [string map [list \r\n \n] \
      [exec -success Success -- $seeExeFileName -hexkey [appendArgs \
      \" $password(4) \"] $dbFileName(4) .dump]]]

  if {$data(8) eq $expected(8)} then {
    host result Ok [appendArgs "PHASE #8: SUCCESS\n"]
  } else {
    host result Error [appendArgs "PHASE #8: FAILURE\n"]
    host result Error [appendArgs "  Expected: \{" $expected(8) \}\n]
    host result Error [appendArgs "  Got: \{" $data(8) \}\n]
  }
} else {
  host result Continue [appendArgs \
      "SEE shell \"" $seeExeFileName "\" not found, test #8 skipped.\n"]
}
